■kubernetes 上で Web サーバを動かしてみよう！
--------------------------------------------------
ここでは、上で構築した kubernetes 環境に nginx(Web サーバ) のコン
テナを動作させる手順を示す。
manifest を作る。
    [root@tkube1 ~]# vi /root/manifests/nginx_test.yaml
    apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
    kind: Deployment
    metadata:
      name: nginx-test       ※ デプロイの名前
    spec:
      selector:
        matchLabels:
          app: nginx-test    ※ デプロイで管理する Pod のラベル(spec.template.metadata.labelsと同じにする)
      replicas: 2            ※ レプリカの数
      template:
        metadata:
          labels:
            app: nginx-test  ※ Pod のラベル
        spec:
          containers:
          - name: master     ※ コンテナの名前
            image: nginx     ※ コンテナイメージ(バージョンを指定する場合は、nginx:1.7.9など)
            resources:
              requests:      ※ デプロイに必要なリソース(CPU/メモリ)の指定
                cpu: 100m       デプロイ時のチェックだけで、Podのリソース制限はされない
                memory: 100Mi   CPUは、millicores(1000m = 1cpu)、メモリは mebibyte で指定。
            ports:
            - containerPort: 80
          restartPolicy: Always  ※ liveness probe で異常を検知したときの動作
                                    Always は、自動的に再起動。
デプロイする。
    [root@tkube1 ~]# kubectl apply -f /root/manifests/nginx_test.yaml
    deployment.apps/nginx-test created
デプロイされたことを確認する。
# kubectl get deploy
NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-test   2         2         2            2           2m
                                              ^^ ★利用可能になったことを確認
ノードポートの manifest を作る。
    [root@tkube1 ~]# vi /root/manifests/nginx_nodeport.yaml
    kind: Service
    apiVersion: v1
    metadata:
      labels:
        k8s-app: nginx-test
      name: nginx-test  ※ サービスの名前
    spec:
      type: NodePort    ※ サービスのタイプ。NodePortでは静的ポートを割り当てサービスを公開する。
                           デフォルト(ClusterIP)ではクラスタ内のみ。クラスタ外からのアクセスには
                           NodePortを利用。
      ports:
      - port: 8080
        targetPort: 80  ※ Podのポート(デプロイで指定したcontainerPort)
        nodePort: 32003 ※ 各ノードから、Podへアクセスするためのポート
      selector:
        app: nginx-test ※ 接続先のPod(デプロイ時に指定したPodのラベル)
適用する。
    [root@tkube1 ~]# kubectl apply -f /root/manifests/nginx_nodeport.yaml
サービスが作成されたことを確認する。
# kubectl get service
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
nginx-test   NodePort    10.102.172.206   <none>        8080:32003/TCP   5s
アクセスを試す。
    [root@tkube1 ~]# curl http://tkube.easter.bs1.cnes.nec.co.jp:32003
    アクセスできれば、次のようなテストページが出力される。
    
    <!DOCTYPE html>
    <html>
    <head>
    <title>Welcome to nginx!</title>
    <style>
        body {
            width: 35em;
            margin: 0 auto;
            font-family: Tahoma, Verdana, Arial, sans-serif;
        }
■kubernetes 上で DB を利用したアプリを動かしてみよう！
--------------------------------------------------
■想定構成
  ベース OS : CentOS7
  kubernetes: 1.11.0 ※ 環境構築済み
  ストレージ: iSCSI(1GB)をあらかじめ用意
■手順概要
・Volumeの定義
mysql用に Volumeを作成する。
manifest を作る。
# vi /root/manifests/persistent_volume.yaml
--------------------
apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-volume
spec:
  capacity:
    storage: 1Gi                           ※ ストレージ容量
  volumeMode: BlockVolume
  accessModes:
    - ReadWriteOnce                        ※ ReadWriteOnce: mountは1ノードのみ。読み書き可
                                              ReadOnlyMany:  mountは複数ノードで可。読み取り専用
                                              ReadWriteMany: mountは複数ノードで可。読み書き可
  persistentVolumeReclaimPolicy: Recycle   ※ 削除時の動作(Retain: 削除しない、Recycle:削除して再利用)
  storageClassName: slow
  iscsi:
    targetPortal: 192.168.222.85:3260      ※ あらかじめ用意しておいたiSCSIディスクを利用
    portals: ['0.0.0.0:3260']
    iqn: iqn.2018-09.localdomain:volume01
    lun: 1
    fsType: xfs
    readOnly: false
--------------------
manifest を適用する。
# kubectl apply -f /root/manifests/persistent_volume.yaml
Volume を確認する
# kubectl get pv
NAME           CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
iscsi-volume   1Gi        RWO            Recycle          Available             slow                     7s
・PVC(persistent_volume_claims) の定義
manifest を作る。
# vi /root/manifests/persistent_volume_claims.yaml
----------------
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: iscsi-volume-claim
  annotations:
    volume.kubernetes.io/storage-class: "iscsi"
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: BlockVolume
  storageClassName: slow
  resources:
    requests:
      storage: 1Gi
----------------
manifest を適用する。
# kubectl create -f /root/manifests/persistent_volume_claims.yaml
PVC を確認する
# kubectl get pvc
NAME                 STATUS    VOLUME         CAPACITY   ACCESS MODES   STORAGECLASS   AGE
iscsi-volume-claim   Bound     iscsi-volume   1Gi        RWO            slow           2m
・ mysqlのデプロイ
# vi /root/manifests/mysql_test.yaml
------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql-test
  template:
    metadata:
      labels:
        app: mysql-test
    spec:
      containers:
        - image: mysql
          name: mysql
          env:
            - name: MYSQL_ROOT_PASSWORD ※ mysqlのルートパスワードの環境変数
              value: root_password      ※ パスワード(秘密情報)のため、運用では secret を利用すべき
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mysql-persistent-storage ※ Volumeの名前(volume.nameと同じにする)
              mountPath: /var/lib/mysql      ※ Volumeをマウントするパス
      volumes:
        - name: mysql-persistent-storage   ※ Volumeに名前を付ける
          persistentVolumeClaim:
            claimName: iscsi-volume-claim  ※ PVCの定義で作成したボリューム名前
------------------
manifest を適用する。
# kubectl apply -f /root/manifests/mysql_test.yaml
デプロイを確認する
# kubectl get deploy
NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
mysql-test   1         1         1            1           2m
・mysqlのサービス
# vi /root/manifests/mysql_clusterip.yaml
------------------
apiVersion: v1
kind: Service
metadata:
  name: mysql-test
spec:
  type: ClusterIP   ※ WordPress(クラスタ内)からのみのアクセスのため、ClusterIPを利用
  ports:
    - port: 3306
  selector:
    app: mysql-test
------------------
manifest を適用する。
# kubectl apply -f /root/manifests/mysql_clusterip.yaml
サービスを確認する
# kubectl get service
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
mysql-test   ClusterIP   10.97.206.167    <none>        3306/TCP         4s
・ wordpress のデプロイ
# vi /root/manifests/wordpress_test.yaml
-------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress-test
  template:
    metadata:
      labels:
        app: wordpress-test
    spec:
      containers:
        - image: wordpress
          name: wordpress
          env:
          - name: WORDPRESS_DB_HOST     ※ WordPressで利用するDBホスト
            value: mysql-test:3306      ※ DBのIPとportを指定する(IPはサービス名で指定が可能)
          - name: WORDPRESS_DB_PASSWORD ※ WordPressで利用するDBのパスワード(mysqlと同じにする)
            value: root_password        
          ports:
            - containerPort: 80
-------------------------
manifest を適用する。
# kubectl apply -f /root/manifests/wordpress_test.yaml
デプロイを確認する
# kubectl get deploy wordpress-test
NAME             DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
wordpress-test   1         1         1            1           4m
・wordpressのサービス
# vi /root/manifests/mysql_nodeport.yaml
-----------------------
apiVersion: v1
kind: Service
metadata:
  name: wordpress-test
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30080
  selector:
    app: wordpress-test
-----------------------
manifest を適用する。
# kubectl apply -f /root/manifests/mysql_nodeport.yaml
サービスを確認する
# kubectl get service wordpress-test
NAME             TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
wordpress-test   NodePort   10.108.74.55   <none>        80:30080/TCP   1h
WordPress にアクセスできることを確認する
# curl http://tkube.easter.bs1.cnes.nec.co.jp:30080/wp-admin/install.php
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

